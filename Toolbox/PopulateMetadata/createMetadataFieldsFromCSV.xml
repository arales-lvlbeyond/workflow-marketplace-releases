<!--
  ~ Levels Beyond CONFIDENTIAL
  ~
  ~ Copyright 2003 - 2020 Levels Beyond Incorporated
  ~ All Rights Reserved.
  ~
  ~ NOTICE:  All information contained herein is, and remains
  ~ the property of Levels Beyond Incorporated and its suppliers,
  ~ if any.  The intellectual and technical concepts contained
  ~ herein are proprietary to Levels Beyond Incorporated
  ~ and its suppliers and may be covered by U.S. and Foreign Patents,
  ~ patents in process, and are protected by trade secret or copyright law.
  ~ Dissemination of this information or reproduction of this material
  ~ is unlawful and strictly forbidden unless prior written permission is obtained
  ~ from Levels Beyond Incorporated.
  -->
<workflow xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns="http://levelsbeyond.com/schema/workflow"
	xsi:schemaLocation="
		http://levelsbeyond.com/schema/latest
		https://s3-us-west-2.amazonaws.com/schema.levelsbeyond.com/2.3.16.17962/studio.xsd
	"
	id="createMetadataFieldsFromCSV"
	name="Create Metadata Fields From CSV"
	executionLabelExpression="Create Metadata Fields From CSV| ${csvFile.name}"
	subjectDOClassName=""
	showInUserInterface="true"
	group="configuration"
	sdkVersion="">

	<initialStepName>convert picklist csv to json</initialStepName>


	<setContextData name="convert picklist csv to json"
		targetDataDef="metadataInfoJsons"
		valueExpression="${#convertCsvToJson(csvFile.absolutePath)}"
		devStep="true"
	>
		<transition condition="${metadataInfoJsons[0].get('name') != null and metadataInfoJsons[0].get('displayName') != null and metadataInfoJsons[0].get('type') != null and metadataInfoJsons[0].get('showInInspector') != null}">
			<targetStepName>prepare list of metadata info to create</targetStepName>
		</transition>
		<transition condition="${true}">
			<targetStepName>invalid format</targetStepName>
		</transition>
	</setContextData>
	
	<groovyStep name="prepare list of metadata info to create"
		executionLabelExpression="Number of metadata entries attempting to be added from given CSV: ${metadataFields.size()}"
		resultDataDef="metadataFields"
		nextStep="get all metadata fields on system"
		devStep="true"
	>
		<script>
			<![CDATA[
				import groovy.json.JsonBuilder
				
				def list = []
				
				metadataInfoJsons.each { field ->
					// ensure boolean string is lower case (comes in as `TRUE` from google sheets)
					field.put('showInInspector', field.get('showInInspector').asText().toLowerCase())
					field.put('multiple', field.get('multiple').asText().toLowerCase())
					
					list.add(field)
				}
				
				return list
			]]>
		</script>
	</groovyStep>
	
	<submitHttpStep name="get all metadata fields on system"
		executionLabelExpression="Fetching all metadata fields on system... | ${reach_url + reachEndpoint}"
		urlExpression="${reach_url + reachEndpoint}"
		requestMethodExpression="GET"
		responseCodeDataDef="responseCode"
		responsePayloadDataDef="responsePayload"
		devStep="true"
	>
		<transition condition="${responseCode.startsWith('2')}">
			<targetStepName>filter fields to create</targetStepName>
		</transition>
		<transition condition="${true}">
			<targetStepName>request failed</targetStepName>
		</transition>
		<requestHeader name="apiKey">${api_key}</requestHeader>
	</submitHttpStep>
	
	<groovyStep name="filter fields to create"
		executionLabelExpression="# of fields to create: ${fieldsToCreate.size()} | # of fields filtered: ${metadataFields.size() - fieldsToCreate.size()}| Create duplicate? == ${createDuplicate}"
		resultDataDef="fieldsToCreate"
	>
		<!-- Create metadata fields -->
		<transition condition="${fieldsToCreate.size() &gt; 0}">
			<targetStepName>set batch to process</targetStepName>
		</transition>
		<transition condition="${true}">
			<targetStepName>no fields to create</targetStepName>
		</transition>
		
		<script>
			<![CDATA[
				list = []
				list = metadataFields
				
				responsePayload?.rows.each { apiField ->
					def fieldExists = false
					def fieldType = apiField.type.asText()
					def fieldName = apiField.name.asText()
					
					metadataFields.any { csvField ->
						// Check if target 'metadataField' picklist exists
						if (fieldType.equals(csvField.type.asText()) && fieldName.equals(csvField.name.asText()))
							fieldExists = true
					}
					
					if (fieldExists && !createDuplicate)
						list.removeAll{ it.name.asText().equals(fieldName) }
					
				}
				
				return list
			]]>
		</script>
	</groovyStep>
	
	<!-- ................................................... Queue Loop ................................................... -->
	<setContextData name="set batch to process"
		targetDataDef="batchToProcess"
		valueExpression="${fieldsToCreate}"
		nextStep="query for running subflows"
		devStep="true"
	/>
	
	<queryStep name="query for running subflows"
		targetDataObjectClass="WorkflowExecution"
		resultDataDef="executingSubflows"
		executionLabelExpression="checking for workflows (with id = ${subflowId}) that are also not in a finished state"
		devStep="true"
		nextStep="check running subflows"
	>
		<criteria>
			<![CDATA[
            <criteria>
                <and>
                     <condition property="workflowVersion.workflow.key" op="eq">
                        <test value="${subflowId}"/>
                    </condition>
                    <condition property="status" op="in">
                        <tests>
                            <test value="CREATED" />
                            <test value="QUEUED" />
                            <test value="EXECUTING" />
                         </tests>
                    </condition>
                </and>
            </criteria>
            ]]>
		</criteria>
	</queryStep>
	
	
	<noopStep name="check running subflows"
		executionLabelExpression="number of subflows (id = ${subflowId}) running >>> ${executingSubflows.size()} out of ${queueLimit}"
		devStep="true"
	>
		<transition condition="${ executingSubflows.size() &lt; queueLimit }">
			<targetStepName>ready next nextBatch</targetStepName>
		</transition>
		<transition condition="${ true }">
			<targetStepName>queue full</targetStepName>
		</transition>
	</noopStep>
	
	
	<delayStep name="queue full"
		delaySecondsExpression="${ queryPollInterval }"
		executionLabelExpression="${batchToProcess.size()} nextBatch remaining | Subflows running: ${executingSubflows.size()}/${queueLimit} | Waiting ${queryPollInterval} seconds."
		nextStep="query for running subflows"
	/>
	
	
	<setContextData name="ready next nextBatch"
		targetDataDef="nextBatch"
		valueExpression="${batchToProcess.size() &gt; batchSize ? batchToProcess.subList(0, batchSize) : batchToProcess.subList(0, batchToProcess.size()) }"
		executionLabelExpression="got ${nextBatch.size()} nextBatch to process"
		nextStep="remove nextBatch from main list"
		devStep="true"
	/>
	
	
	<groovyStep name="remove nextBatch from main list"
		resultDataDef="batchToProcess"
		executionLabelExpression="remove ${nextBatch.size()} nextBatch from the main list"
		nextStep="process nextBatch"
		devStep="true"
	>
		<script>
			<![CDATA[
			batchToProcess.removeAll(nextBatch)
			return batchToProcess
			]]>
		</script>
	</groovyStep>
	
	
	<executeSubflowStep name="process nextBatch"
		executionLabelExpression="Preparing ${nextBatch.size()} nextBatch. | ${batchToProcess.size()} nextBatch remaining | Subflows running: ${executingSubflows.size()}/${queueLimit}"
		targetWorkflowId="${subflowId}"
		subjectChangePath="${nextBatch}"
		subflowTargetDataDef="fieldInfo"
		waitForCompletionExpression="false"
		nextStep="check for more nextBatch"
	/>
	
	<noopStep name="check for more nextBatch"
		executionLabelExpression="number of nextBatch remaining >>> ${batchToProcess.size()}"
		devStep="true"
	>
		<transition condition="${batchToProcess.size() &gt; 0}">
			<targetStepName>query for running subflows</targetStepName>
		</transition>
		<transition condition="true">
			<targetStepName>end</targetStepName>
		</transition>
	</noopStep>
	<!-- ................................................... End Steps .................................................... -->
	<!-- success -->
	<noopStep name="no nextBatch to process"
		pctComplete="99"
		nextStep="end"
	/>
	
	<noopStep name="no fields to create" />
	
	<!-- ................................................... End Steps .................................................... -->
	<failWorkflowStep name="invalid format"
		executionLabelExpression="Given input file is in incorrect format or missing required headers."
		reasonExpression="Given input file is in incorrect format or missing required headers."
	/>
	
	<!-- fail -->
	<failWorkflowStep name="request failed"
		executionLabelExpression="Http Request to ${reachEndpoint} failed. Check parameters used request to reach engine API"
		reasonExpression="Http Request to ${reachEndpoint} failed. Check parameters used request to reach engine API"
	/>
	
	<!-- success -->
	<noopStep name="end" />
	<!-- ................................................... Data Defs .................................................... -->
	<!-- ............ INPUT ............. -->
	<contextDataDef name="csvFile"                                  dataType="File"         label="Metadata Schema CSV:"    userInput="true" />
	<!-- ......... PROCESSING ........... -->
	<contextDataDef name="metadataInfoJsons"                        dataType="JSON"         multiple="true" />
	<contextDataDef name="metadataFields"                           dataType="JSON"         multiple="true" />
	<contextDataDef name="fieldsToCreate"                           dataType="JSON"         multiple="true" />
	<contextDataDef name="createdFields"                            dataType="JSON"         multiple="true"     defaultDataExpression="${T(java.util.Collections).emptyList()}" />
	<contextDataDef name="allCreatedFields"                         dataType="JSON"         multiple="true"     defaultDataExpression="${T(java.util.Collections).emptyList()}" />
 
	<contextDataDef name="apiRequest"                               dataType="String"       defaultDataExpression="${reach_url + reachEndpoint}" />
	<contextDataDef name="responsePayload"                          dataType="JSON" />
	<contextDataDef name="responseCode"                             dataType="String" />
	
	<!-- queue loop variables -->
	<contextDataDef name="batchToProcess"                           dataType="JSON"         multiple="true" />
	<contextDataDef name="nextBatch"                                dataType="JSON"         multiple="true" />
	<contextDataDef name="executingSubflows"                        dataType="Data Object"  multiple="true" />
	<contextDataDef name="queueLimit"                               dataType="Integer"      defaultDataExpression="${#sysconfig('workflows.baseQueueLoop.queueLimit') ?: 2}" />
	<contextDataDef name="batchSize"                                dataType="Integer"      defaultDataExpression="${#sysconfig('workflows.baseQueueLoop.batchSize') ?: 10}" />
	<contextDataDef name="queryPollInterval"                        dataType="Integer"      defaultDataExpression="${#sysconfig('workflows.baseQueueLoop.queryPollInterval') ?: 10}" />
	<contextDataDef name="subflowId"                                dataType="String"       defaultDataExpression="createMetadataField" />

	<!-- Configurations -->
	<contextDataDef name="reach_url"                                dataType="String"       defaultDataExpression="${#sysconfig('workflow.reachUrl')}" />
	<contextDataDef name="api_key"                                  dataType="String"       defaultDataExpression="${#sysconfig('workflow.apiKey')}" />
	<contextDataDef name="reachEndpoint"                            dataType="String"       defaultDataExpression="/reachengine/api/metadata/properties" />
	<contextDataDef name="createDuplicate"                          dataType="Boolean"      defaultDataExpression="${#sysconfig('workflow.createMetadataField.createDuplicate') ?: true}" />
	
</workflow>